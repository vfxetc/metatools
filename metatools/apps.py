import glob
import os
import re
import sys
import datetime
from subprocess import call

import yaml


def main():

    build_time = datetime.datetime.now()
    absolute_self = os.path.abspath(__file__)

    # These two are dependant on the WesternX Python environment.
    local_tools = os.path.abspath(os.path.join(__file__, '..', '..', '..'))
    icons_dir = os.path.join(local_tools, 'key_base', '2d', 'icons')
    
    # dev dir doesn't exist use network build location
    if not os.path.exists(icons_dir):
        local_tools = os.path.abspath(os.path.join(__file__, '..', '..', '..', '..', '..'))
        icons_dir = os.path.join(local_tools, 'key_base', '2d', 'icons')

    args = sys.argv[1:]
    if not args:
        args = glob.glob(os.path.join(os.path.dirname(os.path.abspath(__file__)), '*.yml'))


    for cfg_file in args:    
        config = yaml.load(open(cfg_file).read()) or {}
        
        # Get a name, or use the name of the config file.
        name = config.get('name') or os.path.basename(cfg_file)[:-4]
        safe_name = re.sub(r'\W+', '_', name)
        print '\t' + name + '.app'
        
        # Get the icon, or look for one that matches the name.
        icon = config.get('icon') or name + '.icns'
        icon = os.path.join(icons_dir, icon)
        icon = icon if os.path.exists(icon) else None
        
        # Get the command, defaulting to the name.
        command = config.get('command')
        entrypoint = config.get('entrypoint')
        if entrypoint:
            entrypoint = entrypoint.split(':')
            if len(entrypoint) > 2:
                print 'ERROR: entrypoint must be "package.module" or "package.module:function"'
                continue
        else:
            command = safe_name
        
        bundle_path = '%s.app' % name
        
        # Clean up the old one.
        if os.path.exists(bundle_path):
            for name in os.listdir(bundle_path):
                call(['rm', '-rf', os.path.join(bundle_path, name)])
        
        # Make a bare bundle.
        os.makedirs(os.path.join(bundle_path, 'Contents', 'MacOS'))
        if icon:
            os.makedirs(os.path.join(bundle_path, 'Contents', 'Resources'))
        
        # Copy in the icon.
        if icon:
            call(['cp', icon, os.path.join(bundle_path, 'Contents', 'Resources', os.path.basename(icon))])
        
        # Build the plist
        plist = {}
        plist['CFBundleDisplayName'] = safe_name
        plist['CFBundleIdentifier'] = 'com.keypics.%s' % safe_name
        plist['CFBundleVersion'] = config.get('version', '1.0.0')
        plist['CFBundleExecutable'] = safe_name
        if icon:
            plist['CFBundleIconFile'] = os.path.basename(icon)
        
        with open(os.path.join(bundle_path, 'Contents', 'Info.plist'), 'w') as fh:
            fh.write('''<?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
    <dict>
    ''')
            for k, v in plist.items():
                fh.write('\t<key>%s</key>\n' % k)
                fh.write('\t<string>%s</string>\n' % v)
            fh.write('</dict>\n</plist>\n')
        
        # Build the launcher.
        executable = os.path.join(bundle_path, 'Contents', 'MacOS', safe_name)
        with open(executable, 'w') as fh:
            fh.write('''#!/usr/bin/env bash

    # This file was automatically generated by
    # %(absolute_self)s
    # at %(build_time)s.

    # Build the environment if it doesn't already exist. We try to recreate the
    # bash environment as if invocated with "--login".
    if [[ "$SHLVL" < 2 ]]; then
        
        # Global profile.
        if [[ -f /etc/profile ]]; then
            source /etc/profile
        fi
        
        # User profile.
        for x in ~/.bash_profile ~/.bash_login ~/.profile; do
            if [[ -f $x ]]; then
                source $x
                break
            fi
        done
        
        # Pull in the development environment.
        build_tools="%(local_tools)s"
        if [[ "$build_tools" != "$KS_TOOLS" ]]; then
            eval $(dev --export --site "$build_tools")
        fi

    fi

    # Remove OS X's automatic Process Serial Number. There is apparently no way for
    # us to detect if this will be passed beyond simply looking for it, so make sure
    # that you don't `open` one of these apps and pass it a single argument that
    # starts with "-psn", or it will be removed.
    if [[ "$#" == 1 && "${1:0:4}" == "-psn" ]]; then
        args=""
    else
        args="$@"
    fi

    # Entrypoint specific below here.
    # ===============================

    ''' % locals())

            if entrypoint:
                if len(entrypoint) == 1:
                    fh.write('''exec python -c "import sys; sys.argv[0] = '$0'; import %s" $args\n''' % (entrypoint, ))
                else:
                    fh.write('''exec python -c "import sys; sys.argv[0] = '$0'; import %s; %s.%s()" $args\n''' % (
                        entrypoint[0], entrypoint[0], entrypoint[1],
                    ))
            else:
                fh.write('exec %s $args\n' % command)
                    
        call(['chmod', 'a+x', executable])
        
        # DONE

if __name__ == '__main__':
    main()
