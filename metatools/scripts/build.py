from subprocess import call
import datetime
import os
import sys

import yaml

from metatools.utils import dedent


build_time = datetime.datetime.now()
absolute_self = os.path.abspath(__file__)
local_tools = os.path.abspath(os.path.join(__file__, '..', '..', '..'))



def build_scripts(source, bin_dir, names=None):
    """Build some scripts.

    :param source: Either a ``str`` path to a ``*.yml`` file, or a dict
        mapping script names to their definitions.
    :param str bin_dir: The path to build the scripts into.
    :param list names: Which scripts to build; something falsey implies all.

    """


    if isinstance(source, basestring):
        entrypoints = yaml.load(open(source).read())
    elif isinstance(source, dict):
        entrypoints = source
    else:
        raise TypeError('source must be path to YAML, or a dict.')

    names = names or entrypoints.keys()
    
    if not os.path.exists(bin_dir):
        print '%r does not exist; aborting' % bin_dir
        exit(2)
    
    for name in sorted(names):

        spec = entrypoints.get(name)
        if not spec:
            print '%r is not specified; aborting' % name
            exit(3)

        # Strings are a shortcut for only providing an entrypoint.
        if isinstance(spec, basestring):
            spec = {'entrypoint': spec}

        spec['path'] = os.path.join(bin_dir, name)
        
        print spec['path']

        build_script(**spec)


def build_script(**spec):
    
    # Set some sensible defaults.
    spec.setdefault('type', 'python')
    spec.setdefault('interpreter', spec['type'])
    spec.setdefault('environ', {})
    
    # Python specific defaults.
    spec.setdefault('kwargs', {})
    spec.setdefault('args', ())
    spec.setdefault('module', None)
    spec.setdefault('function', None)
    
    # Bash specific defaults.
    spec.setdefault('command', None)
    
    # Parse a Python string entrypoint.
    entrypoint = spec.pop('entrypoint', None)
    if entrypoint:
        parts = entrypoint.split(':')
        if len(parts) > 2:
            raise ValueError('entrypoint must be "package.module" or "package.module:function"; got %r; aborting %s' % (entrypoint, name))
        spec['module'] = parts[0]
        spec['function'] = parts[1] if len(parts) > 1 else None


    # Make sure it is a type that we understand.
    if spec['type'] not in ('python', 'bash'):
        raise ValueError('unknown entrypoint type %r; aborting %s' % (spec['type'], name))
    
    # Make sure Python entrypoints have a module.
    if spec['type'] == 'python' and not spec['module']:
        raise ValueError('python entrypoint must have a module; aborting %s' % (name, ))
    
    # Make sure bash entrypoints have a command.
    if spec['type'] == 'bash' and not spec['command']:
        raise ValueError('bash entrypoint must have a command; aborting %s' % (name, ))
    
    # This will be concatenated into the final source which will be written.
    source = []
    
    # Shebang.
    source.append('#!/usr/bin/env %(interpreter)s\n' % spec)
    
    # Metadata.
    source.append(dedent('''
        # This file was automatically generated by
        # %(absolute_self)s
        # at %(build_time)s.
     
    ''' % globals()))
    
    # Type specific initialization.
    if spec['type'] == 'python':
        source.append(dedent('''
            import os
            import sys
        
        '''))
            
    if spec['environ']:
        
        if spec['type'] == 'python':
            source.append('os.environ.update({\n')
            for x in sorted(spec['environ'].iteritems()):
                source.append('    %r: %r,\n' % x)
            source.append('})\n\n')
        
        elif spec['type'] == 'bash':
            for k, v in sorted(spec['environ'].iteritems()):
                source.append('export %s=\'%s\'\n' % (k, v.replace('\'', '\'\\\'\'')))
    
    # Call the python code.
    if spec['type'] == 'python':
        source.append('import %(module)s\n' % spec)
        if spec['function']:
            signature = []
            signature.extend(repr(x) for x in spec['args'])
            signature.extend('%s=%r' % x for x in sorted(spec['kwargs'].iteritems()))
            spec.setdefault('signature', ', '.join(signature))
            source.append('%(module)s.%(function)s(%(signature)s)\n' % spec)
    
    elif spec['type'] == 'bash':
        source.append('exec %(command)s $@')
    
    # Write the file.
    with open(spec['path'], 'w') as fh:
        fh.write(''.join(source))
    call(['chmod', '+x', spec['path']])



def main_plural():

    import argparse

    parser = argparse.ArgumentParser()

    parser.add_argument('entrypoints_yaml')
    parser.add_argument('bin_dir')
    parser.add_argument('names', nargs='*')

    args = parser.parse_args()
    build_scripts(args.entrypoints_yaml, args.bin_dir, args.names)
    

